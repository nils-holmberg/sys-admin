<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Clickable Tile Grid → ImageMagick Commands</title>
<style>
  :root { --tile-size: 32px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; line-height: 1.35; }
  .controls { display: flex; gap: 12px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
  .controls label { display: inline-flex; gap: 6px; align-items: center; font-size: 14px; }
  .controls input[type="number"] { width: 80px; padding: 4px 6px; }
  .controls button { padding: 6px 12px; border: 1px solid #ccc; background: #f6f6f6; cursor: pointer; border-radius: 6px; }
  .controls button:hover { background: #eee; }
  #grid { display: grid; grid-auto-rows: var(--tile-size); gap: 0; border: 1px solid #ddd; width: max-content; margin-bottom: 16px; }
  .tile { width: var(--tile-size); height: var(--tile-size); background: limegreen; box-sizing: border-box; user-select: none; }
  .tile.white { background: white; }
  .cmd-wrap { display: grid; gap: 8px; max-width: 100%; margin-top: 12px; }
  .cmd-wrap label { font-size: 14px; color: #333; }
  textarea { width: 100%; min-height: 6.5em; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 13px; border: 1px solid #ccc; border-radius: 6px; }
  .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
</style>
</head>
<body>
  <h1>Clickable Tile Grid → ImageMagick Commands</h1>

  <div class="controls">
    <label>Rows <input id="rows" type="number" min="1" max="100" value="6" /></label>
    <label>Columns <input id="cols" type="number" min="1" max="100" value="6" /></label>
    <button id="build">Build grid</button>
    <button id="clear">Reset (all limegreen)</button>
  </div>

  <div id="grid" aria-label="tile grid"></div>

  <div class="cmd-wrap">
    <div class="row">
      <label for="cmdTiles">Bash <code>convert</code> command (tiles → out.jpg):</label>
      <button id="copyTiles">Copy</button>
    </div>
    <textarea id="cmdTiles" readonly></textarea>

    <div class="row">
      <label for="cmdCircle">Bash <code>convert</code> command (apply circular mask to <code>out.jpg</code> → <code>out-circle.png</code>):</label>
      <button id="copyCircle">Copy</button>
    </div>
    <textarea id="cmdCircle" readonly></textarea>
  </div>

  <script>
    const TILE = 32; // px per tile
    const gridEl = document.getElementById('grid');
    const rowsEl = document.getElementById('rows');
    const colsEl = document.getElementById('cols');
    const buildBtn = document.getElementById('build');
    const clearBtn = document.getElementById('clear');
    const cmdTilesEl = document.getElementById('cmdTiles');
    const cmdCircleEl = document.getElementById('cmdCircle');
    const copyTilesBtn = document.getElementById('copyTiles');
    const copyCircleBtn = document.getElementById('copyCircle');

    function buildGrid(rows, cols) {
      gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--tile-size))`;
      gridEl.innerHTML = '';
      const frag = document.createDocumentFragment();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.dataset.r = r;
          tile.dataset.c = c;
          tile.addEventListener('click', () => {
            tile.classList.toggle('white');
            updateCommands();
          });
          frag.appendChild(tile);
        }
      }
      gridEl.appendChild(frag);
      updateCommands();
    }

    function getWhiteRects() {
      const whites = [];
      gridEl.querySelectorAll('.tile.white').forEach(tile => {
        const r = parseInt(tile.dataset.r, 10);
        const c = parseInt(tile.dataset.c, 10);
        const x1 = c * TILE;
        const y1 = r * TILE;
        const x2 = x1 + TILE - 1;
        const y2 = y1 + TILE - 1;
        whites.push({ r, c, x1, y1, x2, y2 });
      });
      whites.sort((a, b) => (a.r - b.r) || (a.c - b.c));
      return whites;
    }

    function buildTilesCommand(rows, cols, whites) {
      const width = cols * TILE;
      const height = rows * TILE;
      const parts = [];
      if (whites.length === 0) {
        // single-line when no white tiles
        return `convert -size ${width}x${height} xc:limegreen -strip out.jpg`;
      }
      parts.push(`convert -size ${width}x${height} xc:limegreen \\`);
      parts.push(`  -fill white \\`);
      whites.forEach(w => {
        // always end draw lines with a backslash to avoid missing continuation
        parts.push(`  -draw "rectangle ${w.x1},${w.y1} ${w.x2},${w.y2}" \\`);
      });
      parts.push(`  -strip out.jpg`);
      return parts.join('\n');
    }

    function buildCircleCommand(rows, cols) {
      const width = cols * TILE;
      const height = rows * TILE;
      const cx = Math.floor(width / 2);
      const cy = Math.floor(height / 2);
      const r = Math.floor(Math.min(width, height) / 2) - 1; // avoid clipping
      const ex = cx;           // endpoint x on circumference
      const ey = cy - r;       // endpoint y

      return [
        `convert out.jpg \\`,
        `  \\( -size ${width}x${height} xc:none -fill white -draw "circle ${cx},${cy} ${ex},${ey}" \\) \\`,
        `  -alpha off -compose CopyOpacity -composite -alpha on out-circle.png`
      ].join('\n');
    }

    function updateCommands() {
      const rows = parseInt(rowsEl.value || '1', 10);
      const cols = parseInt(colsEl.value || '1', 10);
      const whites = getWhiteRects();
      cmdTilesEl.value = buildTilesCommand(rows, cols, whites);
      cmdCircleEl.value = buildCircleCommand(rows, cols);
    }

    // Buttons
    buildBtn.addEventListener('click', () => {
      const rows = Math.max(1, Math.min(100, parseInt(rowsEl.value || '1', 10)));
      const cols = Math.max(1, Math.min(100, parseInt(colsEl.value || '1', 10)));
      buildGrid(rows, cols);
    });

    clearBtn.addEventListener('click', () => {
      gridEl.querySelectorAll('.tile').forEach(t => t.classList.remove('white'));
      updateCommands();
    });

    async function copyToClipboard(btn, el) {
      try {
        await navigator.clipboard.writeText(el.value);
        btn.textContent = 'Copied!';
        setTimeout(() => (btn.textContent = 'Copy'), 900);
      } catch {
        el.select();
        document.execCommand('copy');
      }
    }
    copyTilesBtn.addEventListener('click', () => copyToClipboard(copyTilesBtn, cmdTilesEl));
    copyCircleBtn.addEventListener('click', () => copyToClipboard(copyCircleBtn, cmdCircleEl));

    // initial grid
    buildGrid(+rowsEl.value, +colsEl.value);
  </script>
</body>
</html>
